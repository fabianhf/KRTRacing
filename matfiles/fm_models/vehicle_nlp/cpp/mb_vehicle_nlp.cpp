/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * mb_vehicle_nlp.cpp
 *
 * Code generation for function 'mb_vehicle_nlp'
 *
 */

/* Include files */
#include "mb_vehicle_nlp.h"
#include <cmath>
#include <math.h>

/* Function Definitions */
void mb_vehicle_nlp(const double states[7], const double controls[5], double
                    statesdot[7], double outputs[3], double j_statesdot[84],
                    double j_outputs[36])
{
  double t2;
  double t4;
  double in1val1;
  double t6;
  double t11;
  double t13;
  double t10;
  double b_t2;
  double t3;
  double b_t4;
  double t9;
  double b_t11;
  double b_t10;
  double t12;
  double b_t13;
  double in4val1;
  double in5val1;
  double in7val1;
  double c_t2;
  double b_t3;
  double b_controls[7];
  double dv[7];
  double dv1[7];
  double dv2[7];
  int i;
  int i1;
  int i2;
  double c_tmp_j_input_tp0f466f37_8fd8_4[84];
  static const signed char b[84] = { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 };

  static const signed char b_b[84] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 };

  static const signed char c_b[48] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
    0, 0, 1, 0, 0, 0, 0, 0 };

  double d_t2[7];
  double dv3[7];
  double dv4[7];
  static const double dv5[12] = { 0.0, 17.21953642384106, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  signed char i3;

  /* mb_vehicle_nlp */
  /*  File automatically generated by FALCON.m */
  /* === Extract Data From Input ============================================== */
  /* === Jacobians and Hessians =============================================== */
  /*  Combine Variables to states */
  /*  Combine Variables to controls */
  /* === Write Constants ====================================================== */
  /* === Call tp293d57ae_a2f3_49ae_8615_ff796093e119 ========================== */
  /* TP293D57AE_A2F3_49AE_8615_FF796093E119 */
  /*     [OUT1,OUT2,OUT3,OUT4,OUT5,OUT6,OUT7,OUT8,OUT9,OUT10,OUT11,OUT12,OUT13,OUT14,OUT15,OUT16,OUT17,OUT18] = TP293D57AE_A2F3_49AE_8615_FF796093E119(IN1VAL1,IN2VAL1,IN3VAL1,IN4VAL1,IN5VAL1,IN6VAL1,IN7VAL1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     17-Jun-2020 02:05:32 */
  t2 = controls[3] * 5.0;
  t4 = states[1] * 10.0;
  in1val1 = -controls[3] * (t4 - 300.0);
  t6 = controls[3] * 14.0;
  t11 = states[1] * 164.4344603763146;
  t13 = pow(t11, t2);
  t10 = pow(4800.0, -t2);

  /*  Hessian Jacobian for tp293d57ae_a2f3_49ae_8615_ff796093e119 */
  /*  Calculation of Jacobian with respect to function global input for tp293d57ae_a2f3_49ae_8615_ff796093e119 */
  /* === Call tp95b4b5b1_df0e_4739_9568_12c275395868 ========================== */
  /* TP95B4B5B1_DF0E_4739_9568_12C275395868 */
  /*     [OUT1,OUT2,OUT3,OUT4,OUT5,OUT6,OUT7,OUT8,OUT9] = TP95B4B5B1_DF0E_4739_9568_12C275395868(IN1VAL1,IN2VAL1,IN3VAL1,IN4VAL1,IN5VAL1,IN6VAL1,IN7VAL1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     17-Jun-2020 02:05:33 */
  b_t2 = std::cos(states[5]);
  t3 = std::sin(states[5]);
  b_t4 = states[4] * controls[4];
  t9 = 1.0 / (b_t4 - 1.0);
  b_t11 = std::sqrt(states[1] * states[1] + states[3] * states[3]);
  b_t10 = t9 * t9;
  t12 = 1.0 / b_t11;
  b_t13 = b_t2 * t9 * b_t11;
  in4val1 = -t3 * b_t11;
  in5val1 = controls[4] * b_t13 + controls[0] * b_t11;

  /*  Hessian Jacobian for tp95b4b5b1_df0e_4739_9568_12c275395868 */
  /*  Calculation of Jacobian with respect to function global input for tp95b4b5b1_df0e_4739_9568_12c275395868 */
  /* === Call tp99d55851_12a5_4024_8ee5_72fed6fd85d0 ========================== */
  /* TP99D55851_12A5_4024_8EE5_72FED6FD85D0 */
  /*     [OUT1,OUT2,OUT3] = TP99D55851_12A5_4024_8EE5_72FED6FD85D0(IN1VAL1,IN2VAL1,IN3VAL1,IN4VAL1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     17-Jun-2020 01:59:06 */
  in7val1 = (controls[1] / 1000.0 + controls[0] * controls[0] / 1.0E+7) + 1.0;

  /*  Hessian Jacobian for tp99d55851_12a5_4024_8ee5_72fed6fd85d0 */
  /*  Calculation of Jacobian with respect to function global input for tp99d55851_12a5_4024_8ee5_72fed6fd85d0 */
  /* === Call tp0f466f37_8fd8_4d3b_9b59_6b6a054367ed ========================== */
  /* TP0F466F37_8FD8_4D3B_9B59_6B6A054367ED */
  /*     [OUT1,OUT2,OUT3,OUT4,OUT5,OUT6,OUT7,OUT8,OUT9,OUT10,OUT11,OUT12,OUT13,OUT14,OUT15,OUT16,OUT17,OUT18,OUT19,OUT20,OUT21] = TP0F466F37_8FD8_4D3B_9B59_6B6A054367ED(IN1VAL1,IN2VAL1,IN3VAL1,IN4VAL1,IN5VAL1,IN6VAL1,IN7VAL1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     16-Jun-2020 14:12:56 */
  c_t2 = 1.0 / -b_t13;
  b_t3 = c_t2 * c_t2;

  /*  Hessian Jacobian for tp0f466f37_8fd8_4d3b_9b59_6b6a054367ed */
  b_controls[0] = controls[3] * -10.0;
  b_controls[1] = 0.0;
  b_controls[2] = 0.0;
  b_controls[3] = 0.0;
  b_controls[4] = 0.0;
  b_controls[5] = 0.0;
  b_controls[6] = -t4 + 300.0;
  dv[0] = 0.0;
  dv[1] = -states[1] * t3 * t12;
  dv[2] = -states[3] * t3 * t12;
  dv[3] = 0.0;
  dv[4] = -b_t2 * b_t11;
  dv[5] = 0.0;
  dv[6] = 0.0;
  dv1[0] = 0.0;
  dv1[1] = states[1] * controls[0] * t12 + states[1] * controls[4] * b_t2 * t9 *
    t12;
  dv1[2] = states[3] * controls[0] * t12 + states[3] * controls[4] * b_t2 * t9 *
    t12;
  dv1[3] = -(controls[4] * controls[4]) * b_t2 * b_t10 * b_t11;
  dv1[4] = -controls[4] * t3 * t9 * b_t11;
  dv1[5] = b_t13 - b_t2 * b_t4 * b_t10 * b_t11;
  dv1[6] = b_t11;
  dv2[0] = 0.0;
  dv2[1] = -states[1] * b_t2 * t9 * t12;
  dv2[2] = -states[3] * b_t2 * t9 * t12;
  dv2[3] = controls[4] * b_t2 * b_t10 * b_t11;
  dv2[4] = t3 * t9 * b_t11;
  dv2[5] = states[4] * b_t2 * b_t10 * b_t11;
  dv2[6] = 0.0;
  t9 = controls[0] / 5.0E+6;
  for (i = 0; i < 12; i++) {
    b_t4 = 0.0;
    b_t11 = 0.0;
    b_t10 = 0.0;
    t12 = 0.0;
    for (i1 = 0; i1 < 7; i1++) {
      i2 = i1 + 7 * i;
      b_t4 += b_controls[i1] * static_cast<double>(b[i2]);
      b_t11 += dv[i1] * static_cast<double>(b_b[i2]);
      b_t10 += dv1[i1] * static_cast<double>(b_b[i2]);
      t12 += dv2[i1] * static_cast<double>(b_b[i2]);
    }

    i1 = i << 2;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i] = b_t4;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i + 1] = 0.0;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i + 2] = 0.0;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i + 3] = b_t11;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i + 4] = b_t10;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i + 5] = t12;
    c_tmp_j_input_tp0f466f37_8fd8_4[7 * i + 6] = t9 * static_cast<double>(c_b[i1])
      + 0.001 * static_cast<double>(c_b[i1 + 1]);
  }

  /*  Calculation of Jacobian with respect to function global input for tp0f466f37_8fd8_4d3b_9b59_6b6a054367ed */
  /*  Combine Variables to statesdot */
  statesdot[0] = c_t2;
  statesdot[1] = in1val1 * c_t2;
  statesdot[2] = 0.0;
  statesdot[3] = 0.0;
  statesdot[4] = in4val1 * c_t2;
  statesdot[5] = in5val1 * c_t2;
  statesdot[6] = in7val1 * c_t2;
  dv[0] = 0.0;
  dv[1] = 0.0;
  dv[2] = 0.0;
  dv[3] = 0.0;
  dv[4] = 0.0;
  dv[5] = -b_t3;
  dv[6] = 0.0;
  d_t2[0] = c_t2;
  d_t2[1] = 0.0;
  d_t2[2] = 0.0;
  d_t2[3] = 0.0;
  d_t2[4] = 0.0;
  d_t2[5] = -in1val1 * b_t3;
  d_t2[6] = 0.0;
  dv1[0] = 0.0;
  dv1[1] = c_t2;
  dv1[2] = 0.0;
  dv1[3] = 0.0;
  dv1[4] = 0.0;
  dv1[5] = 0.0;
  dv1[6] = 0.0;
  dv2[0] = 0.0;
  dv2[1] = 0.0;
  dv2[2] = c_t2;
  dv2[3] = 0.0;
  dv2[4] = 0.0;
  dv2[5] = 0.0;
  dv2[6] = 0.0;
  b_controls[0] = 0.0;
  b_controls[1] = 0.0;
  b_controls[2] = 0.0;
  b_controls[3] = c_t2;
  b_controls[4] = 0.0;
  b_controls[5] = -in4val1 * b_t3;
  b_controls[6] = 0.0;
  dv3[0] = 0.0;
  dv3[1] = 0.0;
  dv3[2] = 0.0;
  dv3[3] = 0.0;
  dv3[4] = c_t2;
  dv3[5] = -in5val1 * b_t3;
  dv3[6] = 0.0;
  dv4[0] = 0.0;
  dv4[1] = 0.0;
  dv4[2] = 0.0;
  dv4[3] = 0.0;
  dv4[4] = 0.0;
  dv4[5] = -in7val1 * b_t3;
  dv4[6] = c_t2;
  for (i = 0; i < 12; i++) {
    b_t4 = 0.0;
    b_t11 = 0.0;
    b_t10 = 0.0;
    t12 = 0.0;
    t9 = 0.0;
    t4 = 0.0;
    b_t2 = 0.0;
    for (i1 = 0; i1 < 7; i1++) {
      t3 = c_tmp_j_input_tp0f466f37_8fd8_4[i1 + 7 * i];
      b_t4 += dv[i1] * t3;
      b_t11 += d_t2[i1] * t3;
      b_t10 += dv1[i1] * t3;
      t12 += dv2[i1] * t3;
      t9 += b_controls[i1] * t3;
      t4 += dv3[i1] * t3;
      b_t2 += dv4[i1] * t3;
    }

    j_statesdot[7 * i] = b_t4;
    j_statesdot[7 * i + 1] = b_t11;
    j_statesdot[7 * i + 2] = b_t10;
    j_statesdot[7 * i + 3] = t12;
    j_statesdot[7 * i + 4] = t9;
    j_statesdot[7 * i + 5] = t4;
    j_statesdot[7 * i + 6] = b_t2;
  }

  /*  Combine Variables to outputs */
  outputs[0] = states[1] * 17.21953642384106;
  t9 = controls[3] * (controls[3] * 14.0 - 15.0);
  t4 = t9 * t10 * t13;
  outputs[1] = t9 * -1040.06 + t4 * 1040.06;
  outputs[2] = t9 * -200.0 + t4 * 200.0;
  t4 = controls[3] * controls[3] * (t6 - 15.0) * t10 * pow(t11, t2 - 1.0);
  b_controls[0] = t4 * 855108.52429494867;
  b_controls[1] = 0.0;
  b_controls[2] = 0.0;
  b_controls[3] = 0.0;
  b_controls[4] = 0.0;
  b_controls[5] = 0.0;
  b_t2 = controls[3] * t10 * t13;
  t3 = (t6 - 15.0) * t10 * t13;
  b_t4 = controls[3] * 8.4763711968959825 * (t6 - 15.0) * t10 * t13;
  t9 = controls[3] * (t6 - 15.0) * t10 * std::log(t11) * t13;
  b_controls[6] = ((((controls[3] * -29121.68 + b_t2 * 14560.84) + t3 * 1040.06)
                    - b_t4 * 5200.3) + t9 * 5200.3) + 15600.9;
  d_t2[0] = t4 * 164434.46037631459;
  d_t2[1] = 0.0;
  d_t2[2] = 0.0;
  d_t2[3] = 0.0;
  d_t2[4] = 0.0;
  d_t2[5] = 0.0;
  d_t2[6] = ((((controls[3] * -5600.0 + b_t2 * 2800.0) + t3 * 200.0) - b_t4 *
              1000.0) + t9 * 1000.0) + 3000.0;
  for (i = 0; i < 12; i++) {
    b_t4 = 0.0;
    b_t11 = 0.0;
    for (i1 = 0; i1 < 7; i1++) {
      i3 = b[i1 + 7 * i];
      b_t4 += b_controls[i1] * static_cast<double>(i3);
      b_t11 += d_t2[i1] * static_cast<double>(i3);
    }

    j_outputs[3 * i] = dv5[i];
    j_outputs[3 * i + 1] = b_t4;
    j_outputs[3 * i + 2] = b_t11;
  }
}

void mb_vehicle_nlp_initialize()
{
}

void mb_vehicle_nlp_terminate()
{
  /* (no terminate code required) */
}

/* End of code generation (mb_vehicle_nlp.cpp) */
