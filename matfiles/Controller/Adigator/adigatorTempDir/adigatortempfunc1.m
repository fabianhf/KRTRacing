function [adigatorFunInfo, adigatorOutputs] = adigatortempfunc1(adigatorFunInfo,adigatorInputs)
[flag, adigatorFunInfo, adigatorInputs] = adigatorFunctionInitialize(1,adigatorFunInfo,adigatorInputs);
if flag; adigatorOutputs = adigatorInputs; return; end;
X_in = adigatorInputs{1};
U = adigatorInputs{2};
p = adigatorInputs{3};
t = adigatorInputs{4};
data = adigatorInputs{5};
nargin = 5; nargout = 1;adigatorVarAnalyzer('%userFunction_Adigator_noConst - Adigator template for user defined function (dynamics constraints) with direct collocation method (h-type)');
adigatorVarAnalyzer('%');
adigatorVarAnalyzer('% Syntax:  [ const ] = userFunction_Adigator_noConst( X_in,U,p,t,data)');
adigatorVarAnalyzer('%');
adigatorVarAnalyzer('% Copyright (C) 2019 Yuanbo Nie, Omar Faqir, and Eric Kerrigan. All Rights Reserved.');
adigatorVarAnalyzer('% The contribution of Paola Falugi, Eric Kerrigan and Eugene van Wyk for the work on ICLOCS Version 1 (2010) is kindly acknowledged.');
adigatorVarAnalyzer('% This code is published under the MIT License.');
adigatorVarAnalyzer('% Department of Aeronautics and Department of Electrical and Electronic Engineering,');
adigatorVarAnalyzer('% Imperial College London London  England, UK');
adigatorVarAnalyzer('% ICLOCS (Imperial College London Optimal Control) Version 2.5');
adigatorVarAnalyzer('% 1 Aug 2019');
adigatorVarAnalyzer('% iclocs@imperial.ac.uk');
adigatorVarAnalyzer('%------------- BEGIN CODE --------------');
f=data.data.InternalDynamics;
f = adigatorVarAnalyzer('f=data.data.InternalDynamics;',f,'f',0);
vdat=data.data;
vdat = adigatorVarAnalyzer('vdat=data.data;',vdat,'vdat',0);
X=X_in;
X = adigatorVarAnalyzer('X=X_in;',X,'X',0);
x0=X_in(1,:)';
x0 = adigatorVarAnalyzer('x0=X_in(1,:)'';',x0,'x0',0);
nt=data.sizes{1};
nt = adigatorVarAnalyzer('nt=data.sizes{1};',nt,'nt',0);
n=data.sizes{3};
n = adigatorVarAnalyzer('n=data.sizes{3};',n,'n',0);
M=data.sizes{7};
M = adigatorVarAnalyzer('M=data.sizes{7};',M,'M',0);
ns=data.sizes{9};
ns = adigatorVarAnalyzer('ns=data.sizes{9};',ns,'ns',0);
t0=t(1);
t0 = adigatorVarAnalyzer('t0=t(1);',t0,'t0',0);
tf=t(end);
tf = adigatorVarAnalyzer('tf=t(end);',tf,'tf',0);
delta_t=tf-t0;
delta_t = adigatorVarAnalyzer('delta_t=tf-t0;',delta_t,'delta_t',0);
T=[0;data.tau_inc]*delta_t/ns+t0;
T = adigatorVarAnalyzer('T=[0;data.tau_inc]*delta_t/ns+t0;',T,'T',0);
P=repmat(p,M,1);
P = adigatorVarAnalyzer('P=repmat(p,M,1);',P,'P',0);
dynF=f(X,U,P,T,vdat);
dynF = adigatorVarAnalyzer('dynF=f(X,U,P,T,vdat);',dynF,'dynF',0);
X_vect=reshape(X',n*M,1);
X_vect = adigatorVarAnalyzer('X_vect=reshape(X'',n*M,1);',X_vect,'X_vect',0);
const=[(x0-data.x0t)*data.cx0;data.map.A*X_vect+data.map.B*reshape(delta_t*dynF',M*n,1)];
const = adigatorVarAnalyzer('const=[(x0-data.x0t)*data.cx0;data.map.A*X_vect+data.map.B*reshape(delta_t*dynF'',M*n,1)];',const,'const',0);
adigatorOutputs = {const};
[adigatorFunInfo, adigatorOutputs] = adigatorFunctionEnd(1,adigatorFunInfo,adigatorOutputs);
